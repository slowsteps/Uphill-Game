package {	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.display.Graphics;	import flash.display.Shape;	import Box2D.Dynamics.*;	import Box2D.Collision.*;	import Box2D.Collision.Shapes.*;	import Box2D.Common.Math.*;	import Box2D.Dynamics.Joints.*;	import flash.display.MovieClip;	import flash.text.TextField;	import fl.transitions.Tween;	import fl.transitions.easing.*;	import flash.utils.getTimer;	import flash.utils.Timer;    import flash.events.TimerEvent;    import flash.geom.Point;			public final class Main extends Sprite {		public var myloader:Loader;		private var world:b2World=new b2World(new b2Vec2(0,10),true);		private var worldScale:int=30;		public var car:b2Body;		public var cardistance:Number=0;		public var zoomcontainer:MovieClip;		private var zoom:Number;		private var pickupClips: Array;		public var carclip:Car;		public var boosteffectclip:BoostEffect;		public var frontwheelclip:Wheel;		public var backwheelclip:Wheel;		private var fuelempty:Boolean = false;		public var rearWheel:b2Body;		public var frontWheel:b2Body;		private var sliceClips:Array;		private var sliceBodies:Array;		private var rearWheelRevoluteJoint:b2RevoluteJoint;		private var frontWheelRevoluteJoint:b2RevoluteJoint;		private var left:Boolean=false;		private var right:Boolean=false;		private var clockwise:Boolean=false;		private var anticlockwise:Boolean=false;		private var glideKeyDown:Boolean=false; //are we gliding?		private var motorSpeed:Number=0;		private var frontAxlePrismaticJoint:b2PrismaticJoint;		private var rearAxlePrismaticJoint:b2PrismaticJoint;		private var debugclip;		private var hillControlpoints:Array; //the points that are interpolated for the hill shape		private var glideParticleEmitter:Emitter;		//car settings		private var fuel:int = 400;		private var carWheelTorque:int = 300;		private var carAirborneTorque:int = 2000;		private var carShockDamper:int = 40;  //bigger is bouncier		private var carAngleDamp:int = 5; //bigger number lowers in the air rotating		private var zoomconstant:int = 8; //lower number, bigger zoom		private var zoomdamping:Number = 0.03; //lower number, slower zoom		private var numhills:int = 400; //big number, big level.		private var maxglidetime:Number = 100; //maximum amount of gliding		private var prescroll:Number = 400; //scroll the level before starting		private var pickupdensity:Number = 0.05 //between 0 and 1 - percentage of pickup		private var fuelconsumption:Number = 1;		private var glidingFuelconsumption:Number = 1;		private var backwheelradius: Number = 80;				public function Main():void {									//car and level will be added to a container clip for zooming			zoomcontainer = new MovieClip();			addChild(zoomcontainer);						zoomcontainer.y=450;			createHillData();			createPickups();			createCar();			createCollisonSystem();			createEffects();			var crosshair = new Crosshair();			//zoomcontainer.addChild(crosshair);						//			//debugDraw();						// ************************ THE CAR ************************ //			// shape			var carShape:b2PolygonShape = new b2PolygonShape();									//width and height of the carbox			carShape.SetAsBox(100/worldScale,20/worldScale);						// fixture			var carFixture:b2FixtureDef = new b2FixtureDef();			carFixture.density=6;			carFixture.friction=0.05;			carFixture.restitution=0.5;			carFixture.filter.groupIndex=-1;			carFixture.shape=carShape;			// body definition			var carBodyDef:b2BodyDef = new b2BodyDef();			carBodyDef.type=b2Body.b2_dynamicBody;			//TODO tune for good looping behaviour			carBodyDef.angularDamping = 0.8;						//position where it's spawned in the world			carBodyDef.position.Set(0.5*800/worldScale,0/worldScale);						// ************************ MERGING ALL TOGETHER ************************ //			// the car itself			car=world.CreateBody(carBodyDef);			car.CreateFixture(carFixture);			car.SetUserData("car");			// ************************ THE AXLES ************************ //			// shape			var axleShape:b2PolygonShape = new b2PolygonShape();			axleShape.SetAsBox(20/worldScale,20/worldScale);			// fixture			var axleFixture:b2FixtureDef = new b2FixtureDef();			axleFixture.density=1;			axleFixture.friction=3;			axleFixture.restitution=0.3;			axleFixture.shape=axleShape;			axleFixture.filter.groupIndex=-1;			// body definition			var axleBodyDef:b2BodyDef = new b2BodyDef();			axleBodyDef.type=b2Body.b2_dynamicBody;						// the rear axle itself			axleBodyDef.position.Set(car.GetWorldCenter().x-(100/worldScale),car.GetWorldCenter().y+(50/worldScale));			var rearAxle:b2Body=world.CreateBody(axleBodyDef);			rearAxle.CreateFixture(axleFixture);			// the front axle itself			axleBodyDef.position.Set(car.GetWorldCenter().x+(100/worldScale),car.GetWorldCenter().y+(50/worldScale));			var frontAxle:b2Body=world.CreateBody(axleBodyDef);			frontAxle.CreateFixture(axleFixture);			// ************************ THE WHEELS ************************ //			// shape			var wheelShape:b2CircleShape=new b2CircleShape(40/worldScale);			var wheelShape2:b2CircleShape=new b2CircleShape(backwheelradius/worldScale);			// fixture			var wheelFixture:b2FixtureDef = new b2FixtureDef();			wheelFixture.density=1;			wheelFixture.friction=6;			wheelFixture.restitution=0.2;			wheelFixture.filter.groupIndex=-1;			wheelFixture.shape=wheelShape;			//bigwheeltest			var wheelFixture2:b2FixtureDef = new b2FixtureDef();			wheelFixture2.density=0.4;			wheelFixture2.friction=10;			wheelFixture2.restitution=0.2;			wheelFixture2.filter.groupIndex=-1;			wheelFixture2.shape=wheelShape2;			//end bigwheel test			// body definition			var wheelBodyDef:b2BodyDef = new b2BodyDef();			wheelBodyDef.type=b2Body.b2_dynamicBody;			// the rear wheel itself			wheelBodyDef.position.Set(car.GetWorldCenter().x-(100/worldScale),car.GetWorldCenter().y+(-0/worldScale));			rearWheel=world.CreateBody(wheelBodyDef);			rearWheel.CreateFixture(wheelFixture2);			rearWheel.SetUserData("rearwheel");			// the front wheel itself			wheelBodyDef.position.Set(car.GetWorldCenter().x+(100/worldScale),car.GetWorldCenter().y+(50/worldScale));			frontWheel=world.CreateBody(wheelBodyDef);			frontWheel.CreateFixture(wheelFixture);			frontWheel.SetUserData("frontwheel");			// ************************ REVOLUTE JOINTS ************************ //			// rear joint			var rearWheelRevoluteJointDef:b2RevoluteJointDef=new b2RevoluteJointDef();			rearWheelRevoluteJointDef.Initialize(rearWheel,rearAxle,rearWheel.GetWorldCenter());			rearWheelRevoluteJointDef.enableMotor=true;			rearWheelRevoluteJointDef.maxMotorTorque=carWheelTorque;			rearWheelRevoluteJoint=world.CreateJoint(rearWheelRevoluteJointDef) as b2RevoluteJoint;			// front joint			var frontWheelRevoluteJointDef:b2RevoluteJointDef=new b2RevoluteJointDef();			frontWheelRevoluteJointDef.Initialize(frontWheel,frontAxle,frontWheel.GetWorldCenter());			frontWheelRevoluteJointDef.enableMotor=true;			frontWheelRevoluteJointDef.maxMotorTorque=carWheelTorque;			frontWheelRevoluteJoint=world.CreateJoint(frontWheelRevoluteJointDef) as b2RevoluteJoint;			// ************************ PRISMATIC JOINTS ************************ //			//  definition			var axlePrismaticJointDef:b2PrismaticJointDef=new b2PrismaticJointDef();			//suspension and shocks range - large number is floppy			axlePrismaticJointDef.lowerTranslation=-carShockDamper/worldScale;			axlePrismaticJointDef.upperTranslation=0/worldScale;			axlePrismaticJointDef.enableLimit=true;			axlePrismaticJointDef.enableMotor=true;			// front axle			axlePrismaticJointDef.Initialize(car,frontAxle,frontAxle.GetWorldCenter(),new b2Vec2(0,1));			frontAxlePrismaticJoint=world.CreateJoint(axlePrismaticJointDef) as b2PrismaticJoint;						// rear axle			axlePrismaticJointDef.Initialize(car,rearAxle,rearAxle.GetWorldCenter(),new b2Vec2(0,1));			rearAxlePrismaticJoint=world.CreateJoint(axlePrismaticJointDef) as b2PrismaticJoint;			addEventListener(Event.ENTER_FRAME,updateWorld);						addEventListener(Event.ADDED_TO_STAGE, stageAddHandler);		}				private function stageAddHandler(e:Event) {			stage.addEventListener(KeyboardEvent.KEY_DOWN,keyPressed);			stage.addEventListener(KeyboardEvent.KEY_UP,keyReleased);		}				public function createCar() {						boosteffectclip = new BoostEffect();			//carclip.addChild(boosteffectclip);			//boosteffectclip.x = -carclip.width/2;			//boosteffectclip.y = carclip.height/2;			frontwheelclip = new Wheel();			zoomcontainer.addChild(frontwheelclip);			carclip = new Car();			zoomcontainer.addChild(carclip);			backwheelclip = new Wheel();			backwheelclip.width = backwheelradius*2;			backwheelclip.height = backwheelradius*2;			zoomcontainer.addChild(backwheelclip);						glideParticleEmitter = new Emitter();			glideParticleEmitter.setup(this,backwheelclip,-100,0);															zoomcontainer.addChild(glideParticleEmitter);						//var dirtParticleEmitter = new Emitter();			//dirtParticleEmitter.setup(this,backwheelclip,-10,50);			//zoomcontainer.addChild(dirtParticleEmitter);								}				//physics hill slice		public function createSlice(posx,slicewidth,y1,y2):b2Body {						var floorShape:b2PolygonShape = new b2PolygonShape();					var floorVector:Vector.<b2Vec2>=new Vector.<b2Vec2>();			floorVector[0]=new b2Vec2(0/worldScale,0/worldScale);			floorVector[1]=new b2Vec2(0/worldScale,-y1/worldScale);			floorVector[2]=new b2Vec2(slicewidth/worldScale,-y2/worldScale);			floorVector[3]=new b2Vec2(slicewidth/worldScale,0/worldScale);			floorShape.SetAsVector(floorVector,4);					var floorFixture:b2FixtureDef = new b2FixtureDef();			floorFixture.density=0;			floorFixture.friction=3;			floorFixture.restitution=0.2;			floorFixture.shape=floorShape;			// body definition			var floorBodyDef:b2BodyDef = new b2BodyDef();						floorBodyDef.position.Set(posx/worldScale,450/worldScale);			// the floor itself			var floor:b2Body=world.CreateBody(floorBodyDef);			floor.CreateFixture(floorFixture);			floor.SetUserData("floor");			return floor;				}				private function debugDraw():void {			var worldDebugDraw:b2DebugDraw=new b2DebugDraw();			var debugSprite:Sprite = new Sprite();			debugclip = zoomcontainer.addChild(debugSprite);			debugclip.y = -450;			worldDebugDraw.SetSprite(debugSprite);			worldDebugDraw.SetDrawScale(worldScale/1);			worldDebugDraw.SetFlags(b2DebugDraw.e_shapeBit|b2DebugDraw.e_jointBit);			worldDebugDraw.SetFillAlpha(0.5);			world.SetDebugDraw(worldDebugDraw);		}				private function keyPressed(e:KeyboardEvent):void {						switch (e.keyCode) {				case 39 :					clockwise = true;					break				case 37 :					anticlockwise = true;					break				case 40 :					left=true;					break;				case 38 :					right=true;					break;				case 32 :					glideKeyDown=true;					break;			}		}		private function keyReleased(e:KeyboardEvent):void {			switch (e.keyCode) {				case 39 :					clockwise = false;					break;				case 37 :					anticlockwise = false;					break;				case 40 :					left=false;					break;				case 38 :					right=false;					break;				case 32 :					glideKeyDown=false;					break;			}		}		private function updateWorld(e:Event):void {						//world.SetGravity(new b2Vec2(0,10));						if (left && !fuelempty) {				motorSpeed+=0.5;			}			if (glideKeyDown && !fuelempty) {				fuel = fuel - glidingFuelconsumption;			}			if (right && !fuelempty) {				motorSpeed-=0.5;				fuel = fuel - fuelconsumption;			}			if (clockwise) {				car.ApplyTorque(carAirborneTorque);			}			if (anticlockwise) {				car.ApplyTorque(-carAirborneTorque);			}			//TODO remove hardcoded damping			if (glideKeyDown && !fuelempty) {				//fx				glideParticleEmitter.emitTimer.start();				carclip.rabbit.head.rotation=10;									//end fx				//only boost when falling					if (car.GetLinearVelocity().y > 0) {					var liftY = -100*car.GetLinearVelocity().x;					//var liftY = car.GetMass()*-10;					var liftforce:b2Vec2 = new b2Vec2(0,liftY);					var liftcenter:b2Vec2 = car.GetWorldCenter();					car.ApplyForce(liftforce,liftcenter);					//car.SetAngularDamping(30);				}			}			//glide key not pressed			else {								glideParticleEmitter.emitTimer.stop();				carclip.rabbit.head.rotation=0			}						//TODO when going fast, there's auto torque			car.SetAngularDamping(carAngleDamp);											//damping			motorSpeed*=0.99;			if (motorSpeed>100) {				motorSpeed=100;			}						//TODO try and understand this						rearWheelRevoluteJoint.SetMotorSpeed(motorSpeed);			frontWheelRevoluteJoint.SetMotorSpeed(motorSpeed);						frontAxlePrismaticJoint.SetMaxMotorForce(Math.abs(800*frontAxlePrismaticJoint.GetJointTranslation()));			frontAxlePrismaticJoint.SetMotorSpeed((frontAxlePrismaticJoint.GetMotorSpeed()-100*frontAxlePrismaticJoint.GetJointTranslation()));									rearAxlePrismaticJoint.SetMaxMotorForce(Math.abs(800*rearAxlePrismaticJoint.GetJointTranslation()));			rearAxlePrismaticJoint.SetMotorSpeed((rearAxlePrismaticJoint.GetMotorSpeed()-100*rearAxlePrismaticJoint.GetJointTranslation()));			world.Step(1/30,10,10);			world.ClearForces();			world.DrawDebugData();						updateVisualWorld();					}						public function setGameOver(reason:String) {			trace(reason);			fuelempty = true;			removeEventListener(Event.ENTER_FRAME,updateWorld);			myloader.reset();		}				private function updateVisualWorld() {			//NOTE any displayobject with an instance name can be diretcly referenced!									if (!fuelempty) updateFuel();			updateDistance();									//zoom camera			var carvelocity:b2Vec2 = car.GetLinearVelocity();			var carspeed: Number = Math.abs(carvelocity.Length());			//var carspeed: Number = Math.abs(carvelocity);			//var carspeed = -0.03*carclip.y;						zoom = zoomcontainer.scaleX + zoomdamping*((zoomconstant/carspeed) - zoomcontainer.scaleX);			//zoomcontainer.y = -carclip.y;						//upper limit			if (zoom>1) {				zoom = 1;			}			else if ( zoom < 1 ) {				zoom = zoom;			}			else {				zoom = 1			}												zoomcontainer.scaleX=zoom;			zoomcontainer.scaleY=zoom;						//debugclip.x = 200 - worldScale*car.GetPosition().x;						//TODO Cache			cardistance = worldScale*car.GetPosition().x;						//BIND car movieclips to bodies and rotate			carclip.x = 800 / 2;			carclip.y = -450 + worldScale*car.GetPosition().y;			carclip.rotation = car.GetAngle() * (180/Math.PI) % 360 ;					backwheelclip.x = carclip.x - cardistance + worldScale*rearWheel.GetPosition().x;			backwheelclip.y = -450 + worldScale*rearWheel.GetPosition().y;			backwheelclip.rotation = rearWheel.GetAngle() * (180/Math.PI) % 360;									frontwheelclip.x = carclip.x - cardistance  + worldScale*frontWheel.GetPosition().x			frontwheelclip.y = -450 + worldScale*frontWheel.GetPosition().y			frontwheelclip.rotation = 50 + frontWheel.GetAngle() * (180/Math.PI) % 360;			//SCROLL PICKUPS TODO needs offscreen culling												for (var i=0;i<pickupClips.length;i++) {				//scroll				pickupClips[i].x = prescroll + pickupClips[i].startx - cardistance;				//collision detection with car				var deltax = pickupClips[i].x - carclip.x;				var deltay = pickupClips[i].y - carclip.y;				var dist = Math.sqrt( (deltax*deltax) + (deltay*deltay));								//if not already collected and in collision with car, remove, add fuel and display fx.				if (!pickupClips[i].collected && dist < 100) {										pickupClips[i].Collect();									}			}									//SCROLL SLICES and optimze for offscreen items			for (var i=0;i<sliceClips.length;i++) {				//TODO safe the startx instead of working with the width				sliceClips[i].x = prescroll + i*sliceClips[i].width - cardistance;								if (sliceClips[i].x < -sliceClips[i].width || sliceClips[i].x > (800/zoomcontainer.scaleX)) {					sliceClips[i].visible = false;					//TODO - only the bodies below the car need to be active, not all in screen					sliceBodies[i].SetActive(false);				}				//clip and body slice onscreen				else {					//trace("Zoom " + zoom);					sliceClips[i].visible = true;					sliceBodies[i].SetActive(true);				}							}				}						private function updateFuel() {			if (fuel < 1) {				fuellabel.text = "out of fuel";				fuelempty = true;				this.setGameOver("out of fuel");			}			else {				fuellabel.text = fuel + " liter";			}		}				//distance related UI and effects				private function createEffects() {			rainbow.alpha=0;			clouds.alpha=0;		}				private function updateDistance() {						distance.text = Math.round(0.01*cardistance) + " meters";			if (cardistance>1000) clouds.alpha += 0.01;			if (cardistance>3000) rainbow.alpha +=0.01;			if (cardistance>4000) clouds.x++;		}						//TODO make 2 dimensonal array with list of x,y pairs. hillfunction should find two surrounding x values and return the interpolated y value.		//or make equal size 1 dimensional array and check for null. Option 1 seems safer.				//create noise array and return interpolated values		public function hillFunction(x:int):Number {			//fil up and array with randon numbers, on random intervals and make block hills.						var x1 = getLower(x)[0];			var y1 = getLower(x)[1];			var x2 = getHigher(x)[0];			var y2 = getHigher(x)[1];			return interpolate(x1,y1,x2,y2,x);					}				private function interpolate(x1,y1,x2,y2,x) {			var ret;						if (x == x1) ret = y1;			else if (x == x2) ret = y2;						else {				var xnorm = (x-x1)/(x2-x1);				//lineair				//ret = y1*(1-xnorm) + y2*xnorm;				//cosine				var ft = xnorm*3.1415927;				var f = (1 - Math.cos(ft))*0.5				ret =  y1*(1-f) + y2*f;			}						return ret;		}				private function getLower(x) : Array {			var ret:Array = new Array();			for (var i=0;i<hillControlpoints.length;i++) {				if (hillControlpoints[i][0] > x) {					ret = hillControlpoints[i-1];					break;				}				else ret = new Array(x,300);			}			return ret;		}				//TODO merge, code duplication		private function getHigher(x) : Array {			var ret:Array = new Array();			for (var i=0;i<hillControlpoints.length;i++) {				if (hillControlpoints[i][0] > x) {					ret = hillControlpoints[i];					break;				}				else ret = new Array(x,300);			}			return ret;		}						private function createHillFunction(){			hillControlpoints = new Array();			for (var i=0;i<numhills+1;i++) {				//TODO change mod 6 into varying gap				if (i%6 == 0) {					var xypair:Array = new Array(); 					var amp:Number;					if (i<13) amp=30;					else amp=500;					xypair[0]=i;					xypair[1]=1+amp*Math.random();					hillControlpoints.push(xypair);					//NOTE this array is smaller than numhills!				}			}					}						//generate segmented procedural hill and make box2d bodies and identical movieclips		public function createHillData() {			//first generate the shape of the hills			createHillFunction();						var slicewidth:int = 100;			var numSlices:int;			numSlices = numhills;						sliceClips = new Array();			sliceBodies = new Array();			for (var i=0;i<numSlices;i++) {				//visual hill slices, fist get two heights from the hillfunction				var y1:Number = hillFunction(i);								var y2:Number = hillFunction(i+1);				var sliceClip:Slice = new Slice();				sliceClip.setNumber(i,slicewidth,y1,y2);				zoomcontainer.addChild(sliceClip);				sliceClip.visible = false;				sliceClip.x = i*slicewidth;				sliceClip.y = 0;				sliceClip.width = slicewidth;				//save in array for scrolling loop				sliceClips.push(sliceClip);								//physics hill slices				var sliceBody:b2Body = createSlice(i*slicewidth,slicewidth,y1,y2);				//save in array for scrolling loop				sliceBodies.push(sliceBody);			}								}				private function createCollisonSystem() {			   	var aCarContactListener:CarContactListener = new CarContactListener();    			world.SetContactListener(aCarContactListener);				//aCarContactListener.mainScript = this;				aCarContactListener.setParentScript(this);		}				public function createPickups() {			pickupClips = new Array();			for (var i=0;i<this.numhills;i++) {				//5% pickup density				if (Math.random()<pickupdensity) {					var aPickup:Pickup = new Pickup();					aPickup.main = this; //pass reference to this					zoomcontainer.addChild(aPickup);					aPickup.setPosition(100*i,-sliceClips[i].top - 100 - 300*Math.random());					pickupClips.push(aPickup);				}			}		}				public function addFuel(addedfuel:int) {						//new Tween(fuellabel, "y", Regular.easeInOut, fuellabel.y, 100, 1, true);			fuel = fuel + addedfuel;		}							}}