package {	import flash.display.Sprite;	import flash.events.Event;	import flash.events.KeyboardEvent;	import flash.display.Graphics;	import flash.display.Shape;	import Box2D.Dynamics.*;	import Box2D.Collision.*;	import Box2D.Collision.Shapes.*;	import Box2D.Common.Math.*;	import Box2D.Dynamics.Joints.*;	import flash.display.MovieClip;	import flash.text.TextField;	import fl.transitions.Tween;	import fl.transitions.easing.*;	import flash.utils.getTimer;			public class Main extends Sprite {		private var world:b2World=new b2World(new b2Vec2(0,10),true);		private var worldScale:int=30;		public var car:b2Body;		public var carscrollpos:Number;		public var zoomcontainer:MovieClip;		private var zoom:Number;		private var pickupClips: Array;		public var carclip:Car;		public var boosteffectclip:BoostEffect;		public var frontwheelclip:Wheel;		public var backwheelclip:Wheel;		private var fuel:Number;		private var fuelempty:Boolean;		public var rearWheel:b2Body;		public var frontWheel:b2Body;		private var sliceClips:Array;		private var sliceBodies:Array;		private var rearWheelRevoluteJoint:b2RevoluteJoint;		private var frontWheelRevoluteJoint:b2RevoluteJoint;		private var left:Boolean=false;		private var right:Boolean=false;		private var clockwise:Boolean=false;		private var anticlockwise:Boolean=false;		private var glide:Boolean=false;		private var motorSpeed:Number=0;		private var frontAxlePrismaticJoint:b2PrismaticJoint;		private var rearAxlePrismaticJoint:b2PrismaticJoint;		//car settings		private var carWheelTorque:int = 300;		private var carAirborneTorque:int = 2000		private var carShockDamper:int = 40;  //bigger is bouncier		private var carAngleDamp:int = 5; //bigger number lowers in the air rotating		private var zoomconstant:int = 10; //lower number, bigger zoom		private var zoomdamping:Number = 0.01; //lower number, slower zoom		private var numhills:int = 1000; //big number, big level.		private var debugclip;		private var hillControlpoints:Array;				public function Main():void {									//car and level will be added to a container clip for zooming			zoomcontainer = new MovieClip();			addChild(zoomcontainer);			var crosshair = new Crosshair();			zoomcontainer.addChild(crosshair);			zoomcontainer.y=450;			fuel=2000;			fuelempty=false;			createHillData();			createPickups();			createCar();			createCollisonSystem();			//			//debugDraw();						// ************************ THE CAR ************************ //			// shape			var carShape:b2PolygonShape = new b2PolygonShape();									//width and height of the carbox			carShape.SetAsBox(100/worldScale,20/worldScale);						// fixture			var carFixture:b2FixtureDef = new b2FixtureDef();			carFixture.density=6;			carFixture.friction=0.05;			carFixture.restitution=0.5;			carFixture.filter.groupIndex=-1;			carFixture.shape=carShape;			// body definition			var carBodyDef:b2BodyDef = new b2BodyDef();			carBodyDef.type=b2Body.b2_dynamicBody;			//TODO tune for good looping behaviour			carBodyDef.angularDamping = 0.8;						//position where it's spawned in the world			carBodyDef.position.Set(0.5*stage.stageWidth/worldScale,0/worldScale);						// ************************ MERGING ALL TOGETHER ************************ //			// the car itself			car=world.CreateBody(carBodyDef);			car.CreateFixture(carFixture);			car.SetUserData("car");			// ************************ THE AXLES ************************ //			// shape			var axleShape:b2PolygonShape = new b2PolygonShape();			axleShape.SetAsBox(20/worldScale,20/worldScale);			// fixture			var axleFixture:b2FixtureDef = new b2FixtureDef();			axleFixture.density=1;			axleFixture.friction=3;			axleFixture.restitution=0.3;			axleFixture.shape=axleShape;			axleFixture.filter.groupIndex=-1;			// body definition			var axleBodyDef:b2BodyDef = new b2BodyDef();			axleBodyDef.type=b2Body.b2_dynamicBody;						// the rear axle itself			axleBodyDef.position.Set(car.GetWorldCenter().x-(100/worldScale),car.GetWorldCenter().y+(50/worldScale));			var rearAxle:b2Body=world.CreateBody(axleBodyDef);			rearAxle.CreateFixture(axleFixture);			// the front axle itself			axleBodyDef.position.Set(car.GetWorldCenter().x+(100/worldScale),car.GetWorldCenter().y+(50/worldScale));			var frontAxle:b2Body=world.CreateBody(axleBodyDef);			frontAxle.CreateFixture(axleFixture);			// ************************ THE WHEELS ************************ //			// shape			var wheelShape:b2CircleShape=new b2CircleShape(40/worldScale);			// fixture			var wheelFixture:b2FixtureDef = new b2FixtureDef();			wheelFixture.density=1;			wheelFixture.friction=6;			wheelFixture.restitution=0.2;			wheelFixture.filter.groupIndex=-1;			wheelFixture.shape=wheelShape;			// body definition			var wheelBodyDef:b2BodyDef = new b2BodyDef();			wheelBodyDef.type=b2Body.b2_dynamicBody;			// the rear wheel itself			wheelBodyDef.position.Set(car.GetWorldCenter().x-(100/worldScale),car.GetWorldCenter().y+(50/worldScale));			rearWheel=world.CreateBody(wheelBodyDef);			rearWheel.CreateFixture(wheelFixture);			rearWheel.SetUserData("rearwheel");			// the front wheel itself			wheelBodyDef.position.Set(car.GetWorldCenter().x+(100/worldScale),car.GetWorldCenter().y+(50/worldScale));			frontWheel=world.CreateBody(wheelBodyDef);			frontWheel.CreateFixture(wheelFixture);			frontWheel.SetUserData("frontwheel");			// ************************ REVOLUTE JOINTS ************************ //			// rear joint			var rearWheelRevoluteJointDef:b2RevoluteJointDef=new b2RevoluteJointDef();			rearWheelRevoluteJointDef.Initialize(rearWheel,rearAxle,rearWheel.GetWorldCenter());			rearWheelRevoluteJointDef.enableMotor=true;			rearWheelRevoluteJointDef.maxMotorTorque=carWheelTorque;			rearWheelRevoluteJoint=world.CreateJoint(rearWheelRevoluteJointDef) as b2RevoluteJoint;			// front joint			var frontWheelRevoluteJointDef:b2RevoluteJointDef=new b2RevoluteJointDef();			frontWheelRevoluteJointDef.Initialize(frontWheel,frontAxle,frontWheel.GetWorldCenter());			frontWheelRevoluteJointDef.enableMotor=true;			frontWheelRevoluteJointDef.maxMotorTorque=carWheelTorque;			frontWheelRevoluteJoint=world.CreateJoint(frontWheelRevoluteJointDef) as b2RevoluteJoint;			// ************************ PRISMATIC JOINTS ************************ //			//  definition			var axlePrismaticJointDef:b2PrismaticJointDef=new b2PrismaticJointDef();			//suspension and shocks range - large number is floppy			axlePrismaticJointDef.lowerTranslation=-carShockDamper/worldScale;			axlePrismaticJointDef.upperTranslation=0/worldScale;			axlePrismaticJointDef.enableLimit=true;			axlePrismaticJointDef.enableMotor=true;			// front axle			axlePrismaticJointDef.Initialize(car,frontAxle,frontAxle.GetWorldCenter(),new b2Vec2(0,1));			frontAxlePrismaticJoint=world.CreateJoint(axlePrismaticJointDef) as b2PrismaticJoint;						// rear axle			axlePrismaticJointDef.Initialize(car,rearAxle,rearAxle.GetWorldCenter(),new b2Vec2(0,1));			rearAxlePrismaticJoint=world.CreateJoint(axlePrismaticJointDef) as b2PrismaticJoint;			addEventListener(Event.ENTER_FRAME,updateWorld);			stage.addEventListener(KeyboardEvent.KEY_DOWN,keyPressed);			stage.addEventListener(KeyboardEvent.KEY_UP,keyReleased);		}				public function createCar() {			carclip = new Car();			zoomcontainer.addChild(carclip);			boosteffectclip = new BoostEffect();			carclip.addChild(boosteffectclip);			boosteffectclip.x = -carclip.width/2;			//boosteffectclip.y = carclip.height/2;						backwheelclip = new Wheel();			zoomcontainer.addChild(backwheelclip);			frontwheelclip = new Wheel();			zoomcontainer.addChild(frontwheelclip);					}				//physics hill slice		public function createSlice(posx,slicewidth,y1,y2):b2Body {						var floorShape:b2PolygonShape = new b2PolygonShape();					var floorVector:Vector.<b2Vec2>=new Vector.<b2Vec2>();			floorVector[0]=new b2Vec2(0/worldScale,0/worldScale);			floorVector[1]=new b2Vec2(0/worldScale,-y1/worldScale);			floorVector[2]=new b2Vec2(slicewidth/worldScale,-y2/worldScale);			floorVector[3]=new b2Vec2(slicewidth/worldScale,0/worldScale);			floorShape.SetAsVector(floorVector,4);					var floorFixture:b2FixtureDef = new b2FixtureDef();			floorFixture.density=0;			floorFixture.friction=3;			floorFixture.restitution=0.2;			floorFixture.shape=floorShape;			// body definition			var floorBodyDef:b2BodyDef = new b2BodyDef();						floorBodyDef.position.Set(posx/worldScale,stage.stageHeight/worldScale);			// the floor itself			var floor:b2Body=world.CreateBody(floorBodyDef);			floor.CreateFixture(floorFixture);			floor.SetUserData("floor");			return floor;				}				private function debugDraw():void {			var worldDebugDraw:b2DebugDraw=new b2DebugDraw();			var debugSprite:Sprite = new Sprite();			debugclip = zoomcontainer.addChild(debugSprite);			debugclip.y = -450;			worldDebugDraw.SetSprite(debugSprite);			worldDebugDraw.SetDrawScale(worldScale/1);			worldDebugDraw.SetFlags(b2DebugDraw.e_shapeBit|b2DebugDraw.e_jointBit);			worldDebugDraw.SetFillAlpha(0.5);			world.SetDebugDraw(worldDebugDraw);		}				private function keyPressed(e:KeyboardEvent):void {						switch (e.keyCode) {				case 39 :					clockwise = true;					break				case 37 :					anticlockwise = true;					break				case 40 :					left=true;					break;				case 38 :					right=true;					break;				case 32 :					glide=true;					break;			}		}		private function keyReleased(e:KeyboardEvent):void {			switch (e.keyCode) {				case 39 :					clockwise = false;					break;				case 37 :					anticlockwise = false;					break;				case 40 :					left=false;					break;				case 38 :					right=false;					break;				case 32 :					glide=false;					break;			}		}		private function updateWorld(e:Event):void {						//world.SetGravity(new b2Vec2(0,10));						if (left && !fuelempty) {				motorSpeed+=0.5;			}			if (right && !fuelempty) {				motorSpeed-=0.5;				fuel-=1;			}			if (clockwise) {				car.ApplyTorque(carAirborneTorque);			}			if (anticlockwise) {				car.ApplyTorque(-carAirborneTorque);			}			//TODO remove hardcoded damping			if (glide) {				car.SetLinearDamping(0.01);				this.backwheelclip.visible = false;				this.frontwheelclip.visible = false;				if (car.GetLinearVelocity().y > 0) {					var liftY = -100*car.GetLinearVelocity().x;					//var liftY = car.GetMass()*-10;					var liftforce:b2Vec2 = new b2Vec2(0,liftY);					var liftcenter:b2Vec2 = car.GetWorldCenter();					car.ApplyForce(liftforce,liftcenter);										//car.SetAngularDamping(30);				}			}			else if (!glide) {				car.SetLinearDamping(0.05);				this.backwheelclip.visible = true;				this.frontwheelclip.visible = true;			}						//TODO when going fast, there's auto torque			car.SetAngularDamping(carAngleDamp);											//damping			motorSpeed*=0.99;			if (motorSpeed>100) {				motorSpeed=100;			}						//TODO try and understand this						rearWheelRevoluteJoint.SetMotorSpeed(motorSpeed);			frontWheelRevoluteJoint.SetMotorSpeed(motorSpeed);						frontAxlePrismaticJoint.SetMaxMotorForce(Math.abs(800*frontAxlePrismaticJoint.GetJointTranslation()));			frontAxlePrismaticJoint.SetMotorSpeed((frontAxlePrismaticJoint.GetMotorSpeed()-100*frontAxlePrismaticJoint.GetJointTranslation()));									rearAxlePrismaticJoint.SetMaxMotorForce(Math.abs(800*rearAxlePrismaticJoint.GetJointTranslation()));			rearAxlePrismaticJoint.SetMotorSpeed((rearAxlePrismaticJoint.GetMotorSpeed()-100*rearAxlePrismaticJoint.GetJointTranslation()));			world.Step(1/30,10,10);			world.ClearForces();			world.DrawDebugData();						updateVisualWorld();					}				public function setGameOver(reason:String) {			trace(reason);			fuelempty = true;			//car.ApplyForce(new b2Vec2(0,100),new b2Vec2(0,0));			var startpos:b2Vec2 = new b2Vec2(0,-300);			trace("before " + car.GetPosition().x)			car.SetActive(false);			car.SetPosition(startpos);			trace("after " + car.GetPosition().x);			//addEventListener(Event.ENTER_FRAME,updateWorld);						//removeEventListener(Event.ENTER_FRAME,updateWorld);		}				private function updateVisualWorld() {						if (!fuelempty) updateFuel();			updateDistance();															//zoom camera			var carvelocity:b2Vec2 = car.GetLinearVelocity();			var carspeed: Number = Math.abs(carvelocity.Length());			//var carspeed: Number = Math.abs(carvelocity);									zoom = zoomcontainer.scaleX + zoomdamping*((zoomconstant/carspeed) - zoomcontainer.scaleX);						if (zoom>1) zoom = 1;															if ( zoom < 1 ) {				zoomcontainer.scaleX=zoom;				zoomcontainer.scaleY=zoom;			}			else {				zoomcontainer.scaleX=1;				zoomcontainer.scaleY=1;							}									//debugclip.x = 200 - worldScale*car.GetPosition().x;						//TODO Cache			//carscrollpos = worldScale*car.GetPosition().x;						//couple car movieclips to bodies and rotate			carclip.x = stage.stageWidth / 2;			carclip.y = -450 + worldScale*car.GetPosition().y;			carclip.rotation = car.GetAngle() * (180/Math.PI) % 360 ;					backwheelclip.x = carclip.x - worldScale*car.GetPosition().x + worldScale*rearWheel.GetPosition().x;			backwheelclip.y = -450 + worldScale*rearWheel.GetPosition().y;			backwheelclip.rotation = rearWheel.GetAngle() * (180/Math.PI) % 360;									frontwheelclip.x = carclip.x - worldScale*car.GetPosition().x  + worldScale*frontWheel.GetPosition().x			frontwheelclip.y = -450 + worldScale*frontWheel.GetPosition().y			frontwheelclip.rotation = 50 + frontWheel.GetAngle() * (180/Math.PI) % 360;			//scroll pickups TODO needs offscreen culling			//TODO cache car.getposition			for (var i=0;i<pickupClips.length;i++) {				pickupClips[i].x = 2000 + 2000*i - this.worldScale*car.GetPosition().x;								var deltax = pickupClips[i].x - carclip.x;				var deltay = pickupClips[i].y - carclip.y;				var dist = Math.sqrt( (deltax*deltax) + (deltay*deltay));												if (!pickupClips[i].collected && dist < 100) {					//fx + increase full via addFuel in this class					pickupClips[i].Collect();					//fuel = fuel + 500;									}			}									//scroll hill and optimze for offscreen items			for (var i=0;i<sliceClips.length;i++) {				sliceClips[i].x = 400 + i*sliceClips[i].width - this.worldScale*car.GetPosition().x;				//clip and body slice offscreen				//TODO check if we're not showing to many clips offscreen with the zoom correction																if (sliceClips[i].x < -sliceClips[i].width || sliceClips[i].x > (stage.stageWidth/zoomcontainer.scaleX)) {					sliceClips[i].visible = false;					//TODO - only the bodies below the car need to be active, not all in screen					sliceBodies[i].SetActive(false);				}				//clip and body slice onscreen				else {					//trace("Zoom " + zoom);					sliceClips[i].visible = true;					sliceBodies[i].SetActive(true);				}							}				}						private function updateFuel() {			if (fuel < 1) {				fuellabel.text = "out of fuel";				fuelempty = true;				this.setGameOver("out of fuel");			}			else {				fuellabel.text = fuel + " liter";			}		}				private function updateDistance() {			//TODO de-duplicate this			distance.text = Math.round(0.01*worldScale*car.GetPosition().x) + " meters";				}						//TODO make 2 dimensonal array with list of x,y pairs. hillfunction should find two surrounding x values and return the interpolated y value.		//or make equal size 1 dimensional array and check for null. Option 1 seems safer.				//create noise array and return interpolated values		public function hillFunction(x:int):Number {			//fil up and array with randon numbers, on random intervals and make block hills.						var x1 = getLower(x)[0];			var y1 = getLower(x)[1];			var x2 = getHigher(x)[0];			var y2 = getHigher(x)[1];			return interpolate(x1,y1,x2,y2,x);					}				private function interpolate(x1,y1,x2,y2,x) {			var ret;						if (x == x1) ret = y1;			else if (x == x2) ret = y2;						else {				var xnorm = (x-x1)/(x2-x1);				//lineair				//ret = y1*(1-xnorm) + y2*xnorm;				//cosine				var ft = xnorm*3.1415927;				var f = (1 - Math.cos(ft))*0.5				ret =  y1*(1-f) + y2*f;			}						return ret;		}				private function getLower(x) : Array {			var ret:Array = new Array();			for (var i=0;i<hillControlpoints.length;i++) {				if (hillControlpoints[i][0] > x) {					ret = hillControlpoints[i-1];					break;				}				else ret = new Array(x,300);			}			return ret;		}				//TODO merge, code duplication		private function getHigher(x) : Array {			var ret:Array = new Array();			for (var i=0;i<hillControlpoints.length;i++) {				if (hillControlpoints[i][0] > x) {					ret = hillControlpoints[i];					break;				}				else ret = new Array(x,300);			}			return ret;		}						private function createHillFunction(){			hillControlpoints = new Array();			for (var i=0;i<numhills+1;i++) {				//TODO change mod 6 into varying gap				if (i%6 == 0) {					var xypair:Array = new Array(); 					xypair[0]=i;					xypair[1]=1+500*Math.random();					hillControlpoints.push(xypair);					//NOTE this array is smaller than numhills!				}			}					}						//generate segmented procedural hill and make box2d bodies and identical movieclips		public function createHillData() {			//first generate the shape of the hills			createHillFunction();						var slicewidth:int = 100;			var numSlices:int;			numSlices = numhills;						sliceClips = new Array();			sliceBodies = new Array();			for (var i=0;i<numSlices;i++) {				//visual hill slices, fist get two heights from the hillfunction				var y1:Number = hillFunction(i);								var y2:Number = hillFunction(i+1);				var sliceClip:Slice = new Slice();				sliceClip.setNumber(i,y1,y2);				zoomcontainer.addChild(sliceClip);				sliceClip.visible = false;				sliceClip.x = i*slicewidth;				sliceClip.y = 0;				sliceClip.width = slicewidth;				//save in array for scrolling loop				sliceClips.push(sliceClip);								//physics hill slices				var sliceBody:b2Body = createSlice(i*slicewidth,slicewidth,y1,y2);				//save in array for scrolling loop				sliceBodies.push(sliceBody);			}								}				private function createCollisonSystem() {			   	var aCarContactListener:CarContactListener = new CarContactListener();    			world.SetContactListener(aCarContactListener);				//aCarContactListener.mainScript = this;				aCarContactListener.setParentScript(this);		}				public function createPickups() {			pickupClips = new Array();			for (var i=0;i<20;i++) {				var aPickup = new Pickup();				aPickup.main = this;				zoomcontainer.addChild(aPickup);				aPickup.y = (-500 - 10*i) + Math.round(200*Math.random());				pickupClips.push(aPickup);			}		}				public function addFuel(addedfuel:int) {						//new Tween(fuellabel, "y", Regular.easeInOut, fuellabel.y, 100, 1, true);			fuel = fuel + addedfuel;		}							}}